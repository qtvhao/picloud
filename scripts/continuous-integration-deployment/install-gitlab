#!/bin/bash
set -e -o pipefail
source .env
if [ -z "$DOMAIN" ]; then
    echo "Please set DOMAIN in .env"
    exit 1
fi
if [ -z "$EMAIL" ]; then
    echo "Please set EMAIL in .env"
    exit 1
fi
set -e -o pipefail
args=("$@")
IDENTIFY_FILE=${args[0]}
stat gitlab.json || \
    jq -n --arg GITLAB_ROOT_GENERATED_PASSWORD "$(openssl rand -hex 16)" '{"gitlab_root_generated_password":$GITLAB_ROOT_GENERATED_PASSWORD}' > gitlab.json

PASSWORD=$(jq -r '.gitlab_root_generated_password' gitlab.json)
echo "Setting password to $PASSWORD"

helm repo add gitlab https://charts.gitlab.io/ || echo ""
helm repo update
kubectl get namespace gitlab-ns || kubectl create namespace gitlab-ns
helm uninstall gitlab --namespace gitlab-ns || true
kubectl get secrets --namespace gitlab-ns -o name | xargs kubectl delete --namespace gitlab-ns || true
kubectl get pvc --namespace gitlab-ns -o name | xargs kubectl delete --namespace gitlab-ns || true
# 
kubectl get secret/redis -n default -o yaml > redis-secret.yaml
sed -i 's/namespace: default/namespace: gitlab-ns/g' redis-secret.yaml
kubectl delete secret --namespace gitlab-ns redis || true
kubectl apply -f redis-secret.yaml
rm redis-secret.yaml
# 
kubectl create secret --namespace gitlab-ns generic gitlab-gitlab-initial-root-password --from-literal=password="$PASSWORD"
helm upgrade --install gitlab gitlab/gitlab \
    --namespace gitlab-ns \
    --set certmanager-issuer.email="$EMAIL",\
global.hosts.kas.name=tcp-gitlab-kas-gitlab-ns-8150."$DOMAIN",\
global.hosts.gitlab.name=http-gitlab-webservice-default-gitlab-ns-8181."$DOMAIN",\
global.hosts.registry.name=http-gitlab-registry-gitlab-ns-5000."$DOMAIN",\
global.hosts.ssh=tcp-gitlab-webservice-default-gitlab-ns-22."$DOMAIN",\
global.edition=ce,\
global.kas.enabled=false,\
gitlab.toolbox.enabled=false,\
gitlab-runner.install=false,\
runners.privileged=true,\
redis.install=false,\
global.redis.host=redis-master.default.svc.cluster.local,\
global.redis.auth.secret=redis,\
global.redis.auth.key=redis-password,\
nginx-ingress.enabled=false,\
gitlab-runner.runners.privileged=true &
#   --set global.ingress.tls.enabled=true,\
# 
# global.appConfig.certmanager.enabled=true,\
# global.edition=ce,\
# certmanager.install=true,\
# global.ingress.configureCertmanager=false,\
# global.kas.tls.enabled=true,\
# nginx-ingress.enabled=false,\
#  &
kubectl delete deployment cloudflared-default -n gitlab-ns || true
TUNNEL_NAMESPACE=gitlab-ns ./pic expose http gitlab-webservice-default.gitlab-ns 8181   502
TUNNEL_NAMESPACE=gitlab-ns ./pic expose http gitlab-registry.gitlab-ns           5000   502
./pic wait deploy       gitlab-minio                    gitlab-ns Available
./pic wait deploy       gitlab-registry                 gitlab-ns Available
# ./pic wait deploy     gitlab-toolbox                  gitlab-ns Available
./pic wait jobs         gitlab-issuer-1                 gitlab-ns complete
./pic wait deploy       gitlab-sidekiq-all-in-1-v2      gitlab-ns Available
./pic wait pod          gitlab-gitaly-0                 gitlab-ns Ready
./pic wait jobs         gitlab-migrations-1             gitlab-ns complete
./pic wait deploy       gitlab-webservice-default       gitlab-ns Available
TUNNEL_NAMESPACE=gitlab-ns ./pic expose tcp     gitlab-gitlab-shell.gitlab-ns   22
TUNNEL_NAMESPACE=gitlab-ns ./pic expose tcp     gitlab-webservice-default.gitlab-ns    22
TUNNEL_NAMESPACE=gitlab-ns ./pic expose http gitlab-webservice-default.gitlab-ns    8181    404
TUNNEL_NAMESPACE=gitlab-ns ./pic expose http gitlab-registry.gitlab-ns              5000    404
# 
export FQDN_RECORD="http-gitlab-webservice-default-gitlab-ns-8181.$DOMAIN"
while true; do
    status_code=$(curl -s -o /dev/null -w "%{http_code}" https://$FQDN_RECORD/users/sign_in || true)
    echo "Waiting for $FQDN_RECORD/users/sign_in to be ready. Status code: $status_code. Expected status code: 200"
    if [ "$status_code" == "200" ]; then
        break
    fi
    sleep 5
done
while true; do
    kubectl get secret --namespace gitlab-ns gitlab-gitlab-initial-root-password && break || sleep 5
done
helm upgrade --install gitlab gitlab/gitlab \
    --namespace gitlab-ns \
    --set certmanager-issuer.email="$EMAIL",\
global.hosts.kas.name=tcp-gitlab-kas-gitlab-ns-8150."$DOMAIN",\
global.hosts.gitlab.name=http-gitlab-webservice-default-gitlab-ns-8181."$DOMAIN",\
global.hosts.registry.name=http-gitlab-registry-gitlab-ns-5000."$DOMAIN",\
global.hosts.ssh=tcp-gitlab-webservice-default-gitlab-ns-22."$DOMAIN",\
global.edition=ce,\
global.kas.enabled=true,\
gitlab.toolbox.enabled=true,\
gitlab-runner.install=true,\
runners.privileged=true,\
redis.install=false,\
global.redis.host=redis-master.default.svc.cluster.local,\
global.redis.auth.secret=redis,\
global.redis.auth.key=redis-password,\
nginx-ingress.enabled=false,\
gitlab-runner.runners.privileged=true &
./pic wait jobs gitlab-migrations-2     gitlab-ns complete
./pic wait deploy       gitlab-gitlab-runner          gitlab-ns Available
TUNNEL_NAMESPACE=default ./pic expose tcp       gitlab-kas.gitlab-ns 8150
TUNNEL_NAMESPACE=default ./pic expose http      gitlab-kas.gitlab-ns 8154 404

PASSWORD=$(kubectl get secret --namespace gitlab-ns gitlab-gitlab-initial-root-password -o jsonpath="{.data.password}" | base64 --decode)
echo "GitLab root password: $PASSWORD"
kubectl create secret docker-registry regcred --docker-server=http-gitlab-registry-5000.$DOMAIN --docker-username=root --docker-password=$PASSWORD --docker-email=$EMAIL || echo ""
# 
GITLAB_OAUTH_URL="https://$FQDN_RECORD/oauth/token"
while true; do
    status_code=$(curl -s -o /dev/null -w "%{http_code}" $GITLAB_OAUTH_URL || true)
    echo "Waiting for $GITLAB_OAUTH_URL to be ready. Status code: $status_code. Expected status code: 302"
    if [ "$status_code" == "302" ]; then
        break
    fi
    sleep 5
done
echo "GITLAB_OAUTH_URL: $GITLAB_OAUTH_URL"
GITLAB_TOKEN=$(curl -s --request POST "$GITLAB_OAUTH_URL" \
--header 'Content-Type: application/json' \
--data-raw '{
    "grant_type": "password",
    "username": "root",
    "password": "'$PASSWORD'"
}' | jq -r '.access_token')

if [ -z "$GITLAB_TOKEN" ]; then
    echo "GITLAB_TOKEN is empty. Please check your credentials."
    exit 1
fi
# 
cat gitlab.json || echo "{}" > gitlab.json
cat gitlab.json | jq -c -n \
    --arg GITLAB_TOKEN "$GITLAB_TOKEN" \
    --arg GITLAB_ROOT_GENERATED_PASSWORD "$PASSWORD" \
    '{"gitlab_token":$GITLAB_TOKEN,"gitlab_root_generated_password":$GITLAB_ROOT_GENERATED_PASSWORD}' > gitlab.json.tmp
mv gitlab.json.tmp gitlab.json
echo "GITLAB_TOKEN: $GITLAB_TOKEN"
if [ -z "$IDENTIFY_FILE" ]; then
    echo "IDENTIFY_FILE is empty. Specify a node ip for the new machine."
    echo "Usage: ./pic recommended IDENTIFY_FILE"
fi
if [ -f $IDENTIFY_FILE ]; then
    SSH_PUB_KEY=$(ssh-keygen -f $IDENTIFY_FILE -y)
    curl --request GET --header "Authorization: Bearer $GITLAB_TOKEN" \
        "https://$FQDN_RECORD/api/v4/user/keys"
        echo "SSH_PUB_KEY: $SSH_PUB_KEY"
    PAYLOAD=$(jq -c -n --arg SSH_PUB_KEY "$SSH_PUB_KEY" '{"title":"gitlab-ssh-key","key":$SSH_PUB_KEY}')
    echo $PAYLOAD > gitlab-ssh-key.json
    curl --request POST --header "Authorization: Bearer $GITLAB_TOKEN" \
        --header "Content-Type: application/json" \
        --data "@gitlab-ssh-key.json" \
        "https://$FQDN_RECORD/api/v4/user/keys"
    rm gitlab-ssh-key.json
fi
